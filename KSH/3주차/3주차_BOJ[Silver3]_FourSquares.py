'''
<배운점>
- 코테 문제는, 생각보다 수학적인 기교를 요구하지 않는다.
  내 생각을, 단순히 코드로 구현만 하면 되는거고, 계산은 컴퓨터가 다 해줌
  -> 수행시간만 신경쓰면서 코드를 작성하면 된다.

  다만, 문제의 수학적 원리에 대한 해석은 요구함.
  이 문제의 경우
  예1) 가장 큰 제곱근이 아닌, 그거보다 더 작은 제곱수가 최적이 될 수 있음
  예2

- 내가 막 n 번째를 예시를 들어가면서 구해볼 필요가 없다.
  n 번째는 컴퓨터가 계산해주는 거고, 나는 단순히 점화식의 관계만 생각하면 됨.
  -> 첫번째나, 맨 끝 극단값 같이 초기값만 구해주면 된다.


<문제 후기>
1. 이 문제 4시간 풀었음.
    DP가 뭔지 감도 안잡혀서 그냥 일단 냅다 계속 봤음.
    근데 풀이는 되게 짧아서 현타옴. 그치만 풀어서 좋긴함.
    + python 제출은 1%에서 시간초과 나는데, pypy3는 정답이여서 좀 어리둥절행중

2. DP가 뭔지 조금씩 감이 잡힌다.
    핵심1. 점화식을 세우기
          점화식에서의 초기값은 어떤 것들인가.
    핵심2. DP 테이블을 업데이트 하는 과정에서, 어떤식으로 업데이트 할 것인가.
          DP 테이블의 초기값은 무엇으로 설정할 것인가.(예; min max 비교를 위해 극단적인 값 or 이 문제처럼 5)
    핵심3. 어떤식으로 반복문을 세우고, 조건을 분기할 것인가.

3. 헷갈련던 부분
    1) 문제를 어떻게 풀어야할지 감이 안잡힘
    - 숫자 네개를 for 문 돌려서 해야되나? -> 이거 브루트포스인데? -> 뭐야 그럼 DP는 어디서 쓰이는건지?
    => 이 문제처럼, 브루트포스가 뒤지게 복잡할거 같다? 그럼 DP 바로 의심 들어가
    2) DP의 핵심 아이디어가 헷갈렸음
    - DP의 핵심은, 해당 case에 대한 값/최댓값/최솟값 자체를 구하면서 가는 것임.
    -> 한번에 여러개를 비교하면서 그 중에서 최적의 값을 구하는 방식이 아님.


<DP 문제 풀이 방법법>
1. case로 나눠서, min or max로 값을 갱신하기
    - 보통, d = d-1 + d-2 꼴이거나, 두 값 중에 min/max 비교하는 식으로 나옴옴

2. 보통은, 바텀업 방식으로, DP 테이블을 구하고,
    마지막에 입력값에 해당하는 결과만 출력하는 식으로 구현.
'''

import math

n = int(input())

# 최소 개수를 저장할 리스트
d = [5] * (n+1)

d[1] = 1

for n in range(2,n+1):
    value = math.sqrt(n) # 
    if value % int(value) == 0:
        d[n] = 1
    else:
        for k in range(int(value), 0, -1):
            # if k**2 < n // 2: # 이 예외 넣으면 안됨. 12 = 2^2 + 2^2 + 2^2 처럼의 케이스가 있음 
            #   -> 항상 예외를 넣을때, 그 예외의 "예외"가 없을지 생각해야함.                                                                      
            #     break
            d[n] = min(d[n], d[n-k**2] + 1)

print(d[n])
        
